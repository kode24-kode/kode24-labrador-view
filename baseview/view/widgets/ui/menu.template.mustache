{{ #get.current.filtered.menus.[[ settings.type ]] }}
<nav class="{{ #helper.trim }}
    navigation 
	{{ selector }} 
	{{ type }}
	[[ #settings.classes ]]
	[[.]]
	[[ /settings.classes ]]
	[[ #settings.expandable ]]expandable[[ /settings.expandable ]]
	[[ #settings.toggleChildren ]]toggleChildren[[ /settings.toggleChildren ]]
	[[ #settings.toggleOnHover ]]toggleOnHover[[ /settings.toggleOnHover ]]
	[[ #settings.scrollableMenu ]]scrollable-menu[[ /settings.scrollableMenu ]]
    {{ /helper.trim }}">
	{{ #showMenuName }}
		{{ #menuName }}
			<p class="lab-menu-name {{ ^showMenuNameOnDesktop}}dac-hidden-desktop-up{{ /showMenuNameOnDesktop}} {{ ^showMenuNameOnMobile }}dac-hidden-desktop-down{{ /showMenuNameOnMobile}}">{{ menuName }}</p>
		{{ /menuName }}
	{{ /showMenuName }}
	<ul class="{{ #helper.trim }}
		menu-list
		[[ #settings.ulClasses ]]
		[[.]]
		[[ /settings.ulClasses ]]
		{{ /helper.trim }}">
		{{ #items }}
			<li class="first-list-item {{ #helper.trim }}
				{{ selector }}
				{{ #selected }} selected{{ /selected }}
				{{ #hasChildren }} has-children{{ /hasChildren }}
				{{ #hideOnDesktop }} dac-hidden-desktop-up{{ /hideOnDesktop }}
				{{ #hideOnMobile }} dac-hidden-desktop-down{{ /hideOnMobile }}
				{{ /helper.trim }}">
				{{ #url }}
				<a href="{{{ url }}}" target="{{ target }}">{{ title }}</a>
				{{ /url }}
				{{ ^url }}
				<span tabindex="0">{{ title }}</span>
				{{ /url }}
				{{ #hasChildren }}
				<ul class="children">
					{{ #children }}
					<li class="{{ #helper.trim }}
						{{ selector }}
						{{ #selected }} selected{{ /selected }}
						{{ #hideOnDesktop }} dac-hidden-desktop-up{{ /hideOnDesktop }}
						{{ #hideOnMobile }} dac-hidden-desktop-down{{ /hideOnMobile }}
						{{ /helper.trim }}">
						{{ #url }}
						<a href="{{{ url }}}" target="{{ target }}">{{ title }}</a>
						{{ /url }}
						{{ ^url }}
						<span>{{ title }}</span>
						{{ /url }}
					</li>
					{{ /children }}
				</ul>
				{{ /hasChildren }}
			</li>
		{{ /items }}
	</ul>
</nav>

[[ #settings.expandable ]]
	[[ ^settings.skipScript ]]
		<script>
			(function () {
				// This is only called when the user presses the escape key.
				function closeElement(event, element) {
					if (event.key === 'Escape') {
						window.removeEventListener('keydown', closeElement);

						// Get all expanded elements and close them
						const expanded = document.querySelectorAll('nav.{{ type }}.expandable .has-children.expanded');
						for (let i = 0; i < expanded.length; i++) {
							expanded[i].classList.remove('expanded');
							
							// Traverse up from the element the user has selected to see if it is a child of the expanded element
							// If it is, set focus to the first child, as that is the span element with tabindex. 
							// This is so that if the user has moved on from the menu, we shouldn't mess with the focus and flow
							if (document.activeElement.closest('.has-children') === expanded[i]) {
								expanded[i].children[0].focus();
							}
						}
					}
				}

				function toggleElement(event, element) {
					// Prevent the default link behavior
					event.preventDefault();

					// Check if there are other expanded elements and close them
					const expanded = document.querySelectorAll('nav.{{ type }}.expandable .has-children.expanded');
					for (let i = 0; i < expanded.length; i++) {
						if (expanded[i] !== element.parentElement) {
							expanded[i].classList.remove('expanded');
						}
					}

					// Toggle the class "expanded" on the parent element
					// We toggle instead of add/remove the class because we don't know if we are opening or closing the element
					element.parentElement.classList.toggle('expanded');

					window.addEventListener('keydown', closeElement);
				}

				// Add extra element for carat and toggle functionality after the span or a element
				function addCarat(element) {
					const carat = document.createElement('span');
					carat.classList.add('carat');
					carat.tabIndex = '0';
					const sibling = element.querySelector(':scope > a') || element.querySelector(':scope > span');
					element.insertBefore(carat, sibling.nextSibling);
					element.tabIndex = '-1';
					if (sibling.tagName === 'A') {
						sibling.tabIndex = '0';
					} else if (sibling.tagName === 'SPAN') {
						sibling.tabIndex = '-1';
					}
				}

				// Get all elements with class "has-children" and add two events - one click event and one keydown event
				// Allow for the same expandable menu to be reused in different viewports by using different classes
				let classes = '[[ #settings.classes ]][[.]] [[ /settings.classes ]]';
				if (classes) {
					classes = '.' + classes.trim().split(' ').join('.');
				}

				const hasChildren = document.querySelectorAll(`nav.{{ type }}${ classes }.expandable .has-children > span`);
				for (let i = 0; i < hasChildren.length; i++) {
					hasChildren[i].addEventListener('click', function(e) {
						toggleElement(e, this);
					});

					hasChildren[i].addEventListener('keydown', function (e) {
						// Check for both enter and space keys
						if (e.key === 'Enter' || e.key === ' ') {
							toggleElement(e, this);
						}
					});
				}

				// Get all elements with class "has-children" when toggleChildren is enabled and carat and toggle functionality 
				const hasChildrenToggle = document.querySelectorAll(`nav.{{ type }}${ classes }.expandable.toggleChildren .has-children > span, nav.{{ type }}${ classes }.expandable.toggleChildren .has-children > a`);
				for (let i = 0; i < hasChildrenToggle.length; i++) {

					// Add carat to the element
					addCarat(hasChildrenToggle[i].parentElement);

					if (hasChildrenToggle[i].tagName === 'A' || hasChildrenToggle[i].tagName === 'SPAN') {
						hasChildrenToggle[i].nextSibling.addEventListener('click', function(e) {
							toggleElement(e, hasChildrenToggle[i]);
						});

						hasChildrenToggle[i].nextSibling.addEventListener('keydown', function(e) {
							// Check for both enter and space keys
							if (e.key === 'Enter' || e.key === ' ') {
								toggleElement(e, hasChildrenToggle[i]);
							}
						});

						// Use with caution - ensure that parent li overlaps with child ul to avoid prematurely triggering leave
						if (hasChildrenToggle[i].closest('nav').classList.contains('toggleOnHover')) {
							hasChildrenToggle[i].addEventListener('mouseenter', function(e) {
								hasChildrenToggle[i].parentElement.classList.add('expanded');
							});

							hasChildrenToggle[i].parentElement.addEventListener('mouseleave', function(e) {
								hasChildrenToggle[i].parentElement.classList.remove('expanded');
							});
						}
					}
				}
			})();
		</script>
	[[ /settings.skipScript ]]
[[ /settings.expandable ]]

[[ #settings.scrollableMenu ]]
	<script>
		(function () {
			// --- Horizontal scroll arrows for scrollable menus ---
			const scrollableMenus = document.querySelectorAll(`nav.{{ type }}.scrollable-menu`);

			scrollableMenus.forEach(function (nav) {
				const list = nav.querySelector('.menu-list');
				if (!list) return;

				const scrollAmount = 200;

				function updateButtons() {
					let maxScroll = list.scrollWidth - list.clientWidth;

					const styles = window.getComputedStyle(list);
					const paddingRight = parseFloat(styles.paddingRight) || 0;
					maxScroll -= paddingRight;

					const tolerance = 2;

					if (list.scrollLeft <= tolerance) {
						leftBtn.classList.add('is-disabled');
					} else {
						leftBtn.classList.remove('is-disabled');
					}

					if (list.scrollLeft >= maxScroll - tolerance) {
						rightBtn.classList.add('is-disabled');
					} else {
						rightBtn.classList.remove('is-disabled');
					}
				}

				function makeButton(side) {
					const btn = document.createElement('button');
					btn.type = 'button';
					btn.className = `menu-scroll menu-scroll--${side}`;
					const ariaLabel = side === 'left' ? '{{ #lang }}header.menuScrollerLeftButton{{ /lang }}' : '{{ #lang }}header.menuScrollerRightButton{{ /lang }}';
					btn.setAttribute('aria-label', ariaLabel);
					btn.innerHTML = side === 'left' ? '‹' : '›';
					return btn;
				}

				const leftBtn = makeButton('left');
				const rightBtn = makeButton('right');

				nav.insertBefore(leftBtn, list);
				nav.appendChild(rightBtn);

				updateButtons();
				list.addEventListener('scroll', updateButtons);

				leftBtn.addEventListener('click', function () {
					list.scrollBy({ left: -scrollAmount, behavior: 'smooth' });
					setTimeout(updateButtons, 300);
				});

				rightBtn.addEventListener('click', function () {
					list.scrollBy({ left: scrollAmount, behavior: 'smooth' });
					setTimeout(updateButtons, 300);
				});
			});
		})();
	</script>
[[ /settings.scrollableMenu ]]

[[ ^settings.skipScript ]]
	<script>
		(function () {
			const menuLinks = document.querySelectorAll(`nav.{{ type }} ul li a`);
			for (let i = 0; i < menuLinks.length; i++) {
				const link = menuLinks[i].pathname;
				if (link === window.location.pathname) {
					menuLinks[i].parentElement.classList.add('lab-link-active');
				} else {
					menuLinks[i].parentElement.classList.remove('lab-link-active');
				}
			}
		})();
	</script>
[[ /settings.skipScript ]]

{{ /get.current.filtered.menus.[[ settings.type ]] }}
