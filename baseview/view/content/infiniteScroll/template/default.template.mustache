<div 
    data-element-guid="{{ get.current.guid }}"
    id="infiniteScroll-{{ get.current.guid }}"
    class="{{ #helper.trim }} 
    column infiniteScroll 
    {{ #style.collection }} box_decoration{{ /style.collection }}
    {{ size.grid.css }}
    {{ size.grid.absCss }}
    {{ /helper.trim }}">
    {{{ get.current.filtered.styleSheets }}}
    <div id="infinity-{{ get.current.guid }}"></div>
    <div id=infiniteTarget-{{ get.current.guid }} class="content {{ #style.collection }}content_decoration{{ /style.collection }}" style="{{ #style.collection }}content_inline_style{{ /style.collection }}">
        {{ #app.isEditor }}
            <p class="infinitePlaceholder">âˆž</p>
            <p class="lab-defaultTextValue">{{ get.current.filtered.sourceInfo }}</p>
            <p class="lab-defaultTextValue">Configure in element settings</p>
        {{ /app.isEditor }}
        {{ #app.isFront }}
            <script>
                function showEverything(id) {
                    const infiniteCollapse = document.getElementById(`infiniteCollapse-${ id }`);
                    infiniteCollapse.classList.add("infiniteVisibility");
                    const bodyText = document.querySelector(`#main-${ id } .bodytext`);
                    bodyText.classList.remove("infiniteRelativity");
                    const visibilityButton = document.getElementById(`infiniteButton-${ id }`);
                    const infiniteFade = document.getElementById(`infiniteFade-${ id }`);
                    infiniteFade.classList.add("infiniteInvisibility");
                    visibilityButton.classList.remove("infiniteVisibility");
                    visibilityButton.classList.add("infiniteInvisibility");
                }

                function collapseArticle(id) {
                    const bodyText = document.querySelector(`#main-${ id } .bodytext`);
                    const bodyTextChildren = Array.from(bodyText.children);
                    const paragraphs = [];
                    bodyTextChildren.forEach((element, index) => {
                        if (element.tagName === "P") {
                            paragraphs.push({ element, index }); // extract paragraphs, retain original index in body text
                        }
                    });
                    if (paragraphs && paragraphs.length > 2) {
                        const secondParagraph = paragraphs[1].element;
                        bodyText.classList.add("infiniteRelativity");
                        for (let i = 0; i <= paragraphs[1].index; i++) {                  
                            bodyTextChildren[i].classList.add("infiniteVisibility");
                        }
                        const secondRectangle = secondParagraph.getBoundingClientRect();
                        secondParagraph.insertAdjacentHTML("afterbegin", `<div id="infiniteFade-${ id }" class="infiniteFade"></div>`);
                        if (!document.getElementById(`infiniteButton-${ id }`)) {
                            secondParagraph.insertAdjacentHTML("afterend", `<button id="infiniteButton-${ id }" onclick="showEverything(${ id })" class="infiniteButton infiniteVisibility" id=infiniteButton-${ id }>{{ #lang }}infiniteScroll.readMore{{ /lang }}</button>`);
                        }
                        const backgroundColor = window.getComputedStyle(document.body).getPropertyValue("background-color");
                        const backgroundColorWithOpacity = backgroundColor.replace("rgb", "rgba");
                        const backgroundColorWithOpacityStart = backgroundColorWithOpacity.replace(")", ", 1)");
                        const backgroundColorWithOpacityStop = backgroundColorWithOpacity.replace(")", ", 0)");
                        const infiniteFade = document.getElementById(`infiniteFade-${ id }`);
                        infiniteFade.setAttribute("style", `height: ${ secondRectangle.height + 80 }px; background: linear-gradient(0deg, ${ backgroundColorWithOpacityStart } 30%, ${ backgroundColorWithOpacityStop } 100%);`); // margin-bottom: 5rem;
                    } else {
                        // if fewer than 2 paragraphs, show everything
                        const infiniteCollapse = document.getElementById(`infiniteCollapse-${ id }`);
                        infiniteCollapse.classList.add("infiniteVisibility");
                    }
                };

                function observeArticle(id, url) {
                    const articleOptions = {
                        root: null,
                        rootMargin: "0px",
                        threshold: [0, 0.25, 0.50, 0.75, 1.0]
                    };
                    const articleCallback = (entries, observer) => {
                        entries.forEach((entry) => {
                            if (entry.isIntersecting) {
                                // when scrolling down, check when top is more than halfway up
                                // when scrolling up, check when bottom is more than halfway down  
                                if ((entry.target.getBoundingClientRect().top > 0 && entry.target.getBoundingClientRect().top < (window.innerHeight / 2)) || (entry.target.getBoundingClientRect().top < 0 && entry.target.getBoundingClientRect().bottom > (window.innerHeight / 2))) {
                                    const currentId = window.location.pathname.split("/").pop();
                                    const currentArticle = document.getElementById(`infiniteArticle-${ id }`);
                                    const currentArticleUrl = currentArticle.getAttribute("data-article-url") || `${ window.location.origin }${ url}`;
                                    const currentArticleEncodedUrl = encodeURI(currentArticleUrl);
                                    if (id !== currentId) {
                                        window.history.replaceState({}, "", currentArticleEncodedUrl);
                                        if (typeof pbjs !== "undefined" && pbjs.setConfig) {
                                            pbjs.setConfig({ pageUrl: currentArticleEncodedUrl });
                                        }
                                        currentArticle.classList.add("observed");
                                        const lab_article_data = {
                                             tagsString: '{{{ get.current.filtered.tagsString }}}',
                                        };
                                        if (window.Dac && window.Dac.InfinityScrollAds) {
                                            const scrollads = new Dac.InfinityScrollAds(id, currentId, entry);
                                            scrollads.reloadSkyscraperAds();   
                                        } else {
                                            console.warn('ElementAttributeToggler: Missing required class Dac.InfinityScrollAds.');
                                        }
                                    } else {
                                        currentArticle.classList.remove("observed");
                                    }
                                } 
                            }
                        });
                    };
                    const articleObserver = new IntersectionObserver(articleCallback, articleOptions);
                    const articleTarget = document.getElementById(id);
                    articleObserver.observe(articleTarget);
                }

                function setupAdIntersectionObserver(id) {
                    const adObserverOptions = {
                        root: null,
                        rootMargin: `${window.innerHeight * 4}px 0px ${window.innerHeight * 4}px 0px`,
                        threshold: 0
                    };

                    const adObserverCallback = (entries, observer) => {
                        entries.forEach((entry) => {
                            if (entry.isIntersecting) {
                                const currentId = window.location.pathname.split("/").pop();
                                if (window.Dac && window.Dac.InfinityScrollAds) {
                                    const scrollads = new Dac.InfinityScrollAds(id);
                                    scrollads.reloadArticleAds();
                                } else {
                                    console.warn('ElementAttributeToggler: Missing required class Dac.InfinityScrollAds.');
                                }
                                observer.unobserve(entry.target);
                            }
                        });
                    };

                    const target = document.getElementById(`infiniteArticle-${id}`);
                    if (target) {
                        const adObserver = new IntersectionObserver(adObserverCallback, adObserverOptions);
                        adObserver.observe(target);
                    } else {
                        console.warn(`Target element infiniteArticle-${id} not found for ad observer.`);
                    }
                }

                (function() {
                    // prevent fetching infinite scroll inside infinite scroll
                    if ("{{ get.root.fields.page_template_alias }}" !== "infinitescroll") {
                        const apiUrl = "{{{ getCmsConfig.front_api_url }}}";
                        const domain = "{{{ getCmsConfig.site.domain }}}";
                        const siteId = "{{ getCmsConfig.site.id }}";
                        const rootId = "{{ get.root.id }}";
                        const rootUrl = window.location.pathname; // original URL
                        const articles = [];
                        const isArticle = "{{ get.root.type }}" === "page_article";
                        const infiniteSource = "{{ get.current.fields.feed }}" ? "feed" : "{{ get.current.filtered.infiniteSource }}";
                        const infiniteFeed = "{{ get.current.fields.feed }}" || "{{ get.current.filtered.infiniteFeed }}";

                        const infiniteOptions = {
                            root: null,
                            rootMargin: `${ window.innerHeight * 2 }px`,
                            threshold: [0, 0.25, 0.50, 0.75, 1.0]
                        };

                        let isReady = true;
                        
                        const infiniteCallback = (entries, observer) => {
                            entries.forEach((entry) => {
                                if (entry.isIntersecting && isReady && articles.length > 0) {
                                    isReady = false;
                                    let articleBatch = articles.splice(0, 5);
                                    let remainingArticles = articleBatch.length;
                                    articleBatch.forEach((article) => {
                                        remainingArticles--;
                                        if (article.url) {
                                            fetch(`${ domain }${ article.url }?lab_opts=infinitescroll`) 
                                                .then((response) => {
                                                    if (!response.ok) {
                                                        throw new Error(`Could not fetch article: ${ response.status } - ${ response.statusText }`);
                                                    } else {
                                                        return response.text();
                                                    }
                                                })
                                                .then((response) => {
                                                    const articleContainer = document.createElement("div");
                                                    articleContainer.id = article.id;
                                                    articleContainer.appendChild(document.createRange().createContextualFragment(response));
                                                    const infinity = document.getElementById("infinity-{{ get.current.guid }}");
                                                    infinity.appendChild(articleContainer);
                                                    if (window.Dac && window.Dac.Definition) {
                                                        const definition = new Dac.Definition(`infiniteSection-${ article.id }`);
                                                        definition.setup();   
                                                    }
                                                    collapseArticle(article.id);
                                                    observeArticle(article.id, article.url);
                                                    setupAdIntersectionObserver(article.id);
                                                })
                                                .catch((error) => console.log(error))
                                                .finally(() => {
                                                    if (remainingArticles === 0) {
                                                        isReady = true;
                                                    }
                                                });
                                        } else {
                                            if (remainingArticles === 0) {
                                                isReady = true;
                                            }
                                        }
                                    });
                                } 
                            });
                        };
                        const infiniteTarget = document.getElementById("infiniteTarget-{{ get.current.guid }}");
                        if (infiniteSource === "api") {
                            fetch(`${ apiUrl }/article?site_id=${ siteId }&query=NOT paywall:*`) // "paywall": "" or no paywall property
                                .then((response) => {
                                    if (!response.ok) {
                                        throw new Error(`Could not fetch articles from Labrador API: ${ response.status } - ${ response.statusText }`);
                                    } else {
                                        return response.json();
                                    }
                                })
                                .then((response) => {
                                    response.result.forEach((entry) => {
                                        if (((isArticle && entry.id !== rootId) || !isArticle) && !(articles.some(((article) => article.id === entry.id)))) {
                                            articles.push({ id: entry.id, url: entry.published_url });
                                        }
                                    });
                                    infiniteObserver = new IntersectionObserver(infiniteCallback, infiniteOptions);
                                    infiniteObserver.observe(infiniteTarget);
                                })
                                .catch((error) => console.log(error));
                        } else if (infiniteSource === "feed") {
                            fetch(`${ apiUrl }/feed/data/${ infiniteFeed }`)
                                .then((response) => {
                                    if (!response.ok) {
                                        throw new Error(`Could not fetch articles from feed: ${ response.status } - ${ response.statusText }`);
                                    } else {
                                        return response.json();
                                    }
                                })
                                .then((response) => {
                                    if (response && response.entries) {
                                        response.entries.forEach((entry) => {
                                            if (((isArticle && entry.id !== rootId) || !isArticle) && entry.siteDomain === domain && !entry.paywall && !(articles.some(((article) => article.id === entry.id)))) {
                                                articles.push({ id: entry.id, url: entry.url });
                                            }
                                        });
                                        infiniteObserver = new IntersectionObserver(infiniteCallback, infiniteOptions);
                                        infiniteObserver.observe(infiniteTarget);
                                    }
                                })
                                .catch((error) => console.log(error));
                        }
                        // navigate to original URL if infinite scroll element is no longer visible
                        const rootOptions = {
                            root: null,
                            rootMargin: "0px",
                            threshold: [0, 0.25, 0.50, 0.75, 1.0]
                        };
                        const rootCallback = (entries, observer) => {
                            entries.forEach((entry) => {
                                if (!entry.isIntersecting) {
                                    const query = location.search;
                                    window.history.replaceState({}, "", rootUrl + query);
                                } 
                            }); 
                        };
                        const rootObserver = new IntersectionObserver(rootCallback, rootOptions);
                        const rootTarget = document.getElementById("infinity-{{ get.current.guid }}");
                        rootObserver.observe(rootTarget);
                    }
                })();
            </script>
        {{ /app.isFront }}
    </div>
</div>
